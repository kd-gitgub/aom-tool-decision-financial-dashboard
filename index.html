<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3a6f 0%, #2c5282 100%);
            min-height: 100vh;
            padding: 15px;
            color: #001C66;
        }
        
        .dashboard-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .dashboard-header {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 12px;
            padding: 16px 24px;
            margin-bottom: 16px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.08);
        }
        
        .dashboard-title {
            color: #001C66;
            font-size: 24px;
            font-weight: 600;
        }
        
        .controls-row {
            display: flex;
            gap: 16px;
            align-items: flex-start;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .control-label {
            font-size: 11px;
            color: #001C66;
            text-transform: none;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        
        .control-group.active-decisions-group {
            flex-basis: 100%;
            width: 100%;
        }
        
        @media (min-width: 992px) {
            .control-group.active-decisions-group {
                flex-basis: auto;
                flex: 1;
                width: auto;
                min-width: 300px;
            }
        }
        
        .dropdown-container {
            position: relative;
            min-width: 250px;
        }
        
        .dropdown-button {
            width: 100%;
            padding: 8px 32px 8px 10px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            color: #001C66;
            text-align: left;
            position: relative;
            transition: all 0.2s;
        }
        
        .dropdown-button:hover {
            border-color: #3b82f6;
        }
        
        .dropdown-button::after {
            content: 'â–¼';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #001C66;
        }
        
        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-top: 3px;
            max-height: 250px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        
        .dropdown-menu.show {
            display: block;
        }
        
        .dropdown-item {
            padding: 8px 10px;
            display: flex;
            align-items: flex-start;
            gap: 6px;
            cursor: pointer;
            transition: background 0.2s;
            min-height: 32px;
            color: #001C66;
        }
        
        .dropdown-item:hover {
            background: #f1f5f9;
        }
        
        .dropdown-item.select-all {
            border-bottom: 2px solid #e2e8f0;
            font-weight: 600;
            align-items: center;
        }
        
        .dropdown-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            margin-top: 1px;
        }
        
        .view-toggle {
            display: flex;
            background: #f1f5f9;
            border-radius: 6px;
            padding: 3px;
        }
        
        .view-option {
            padding: 6px 12px;
            border: none;
            background: transparent;
            color: #001C66;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .view-option.active {
            background: white;
            color: #001C66;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .metrics-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 0;
        }
        
        @media (max-width: 768px) {
            .metrics-row {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 480px) {
            .metrics-row {
                grid-template-columns: 1fr;
            }
        }
        
        .metric-card {
            background: white;
            border-radius: 6px;
            padding: 12px 16px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            position: relative;
            min-height: 60px;
            border-left: 6px solid #001c66;
        }
        
        .metric-label {
            color: #001c66;
            font-size: 0.8em;
            text-transform: none;
            letter-spacing: 0.5px;
            font-weight: 400;
            opacity: 1;
            margin-bottom: 2px;
        }
        
        .metric-value {
            color: #001C66;
            font-size: 24px;
            font-weight: 700;
            display: flex;
            align-items: baseline;
            margin-bottom: 0;
        }
        
        .metric-suffix {
            color: #001c66;
            font-size: 16px;
            font-weight: 600;
            margin-left: 3px;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px 24px;
            padding-bottom: 24px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
        }
        
        .chart-wrapper {
            position: relative;
            min-height: 380px;
            width: 100%;
            overflow: hidden;
            margin: 0 auto;
            display: block;
        }
        
        .chart-title {
            color: #001C66;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .status-indicator.loaded {
            background: #10b981;
        }
        
        .status-indicator.empty {
            background: #ef4444;
        }
        
        #waterfallChart {
            width: 100%;
            height: 100%;
        }
        
        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 250px;
        }
        
        .tooltip.visible {
            opacity: 1;
        }
        
        .bar {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .bar:hover {
            opacity: 0.9;
        }
        
        .connector-line {
            stroke: #cbd5e0;
            stroke-width: 2;
            stroke-dasharray: 4,2;
            opacity: 0.5;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #001C66;
        }
        
        .legend-color {
            width: 16px;
            height: 10px;
            border-radius: 2px;
        }
        
        .decision-chip {
            display: inline-flex;
            align-items: center;
            padding: 2px 6px 2px 0px;
            background: #f8fafc;
            border-radius: 0px;
            border: none;
            font-size: 11px;
            font-weight: 500;
            color: #001C66;
            transition: all 0.2s;
            cursor: default;
            height: 18px;
            white-space: nowrap;
        }
        
        .decision-chip.inactive {
            opacity: 0.4;
            background: #f1f5f9;
        }
        
        .decision-chip:hover:not(.inactive) {
            transform: translateY(-1px);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="dashboard-header">
            <h1 class="dashboard-title" style="margin-bottom: 12px;">Test</h1>
            
            <div class="metrics-row" style="margin-bottom: 0; background: rgba(248, 250, 252, 0.5); padding: 8px; border-radius: 6px;">
                <div class="metric-card">
                    <div class="metric-value">
                        <span id="totalNPV">$0</span>
                        <span class="metric-suffix">k</span>
                        <div id="waccInline" style="margin-left:20px; font-size:13px; font-weight:600; color:#001C66; display:flex; align-items:baseline;">
                            WACC = <span id="waccDisplay" style="margin-left:6px;">7.35%</span>
                        </div>
                    </div>
                    <div class="metric-label">Total NPV</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">
                        <span id="totalCosts">$0</span>
                        <span class="metric-suffix">k</span>
                    </div>
                    <div class="metric-label">Total Costs</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">
                        <span id="totalSavings">$0</span>
                        <span class="metric-suffix">k</span>
                    </div>
                    <div class="metric-label">Total Savings</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">
                        <span id="netBenefit">$0</span>
                        <span class="metric-suffix">k</span>
                    </div>
                    <div class="metric-label">Net Benefit</div>
                </div>
            </div>
        </div>
        
        <div class="dashboard-header" style="margin-bottom: 16px; padding: 10px 24px;">
            <div class="controls-row" style="gap: 12px;">
                <div class="control-group" style="gap: 4px;">
                    <span class="control-label">Decisions</span>
                    <div class="dropdown-container">
                        <button class="dropdown-button" id="decisionDropdown">
                            <span class="status-indicator empty"></span>
                            Select Decisions
                        </button>
                        <div class="dropdown-menu" id="decisionMenu">
                            <div class="dropdown-item select-all">
                                <input type="checkbox" id="selectAll">
                                <label for="selectAll">Select All</label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-group" style="gap: 4px;">
                    <span class="control-label">View</span>
                    <div class="view-toggle">
                        <button class="view-option" data-view="aggregated">Program</button>
                        <button class="view-option active" data-view="detailed">Decisions</button>
                    </div>
                </div>
                
                
            </div>
        </div>
        
        <div class="chart-container">
            <h2 class="chart-title" id="chartTitle">Quarterly Cashflow Waterfall</h2>
            <div class="chart-wrapper" id="waterfallChart"></div>
            <div class="legend" id="legend"></div>
        </div>

        <div class="dashboard-header" style="margin-top: 12px; padding: 10px 18px;">
            <div class="control-group active-decisions-group" id="activeDecisionsGroup" style="gap: 6px;">
                <span class="control-label" style="display: inline-flex; align-items: center; gap: 6px; margin-bottom: 2px;">
                    All Decisions
                    <span style="font-size: 10px; color: #001C66; background: #f1f5f9; padding: 1px 6px; border-radius: 8px; font-weight: 600;" id="decisionCount">0 selected</span>
                </span>
                <div id="selectedDecisionsList" style="display: flex; flex-wrap: wrap; gap: 4px; margin-left: 0; padding-left: 0;"></div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>
    
    <script>
        let decisionData = [];
        let selectedDecisions = new Set();
        let currentView = 'detailed';
        let currentQuarter = 'all';
        
        // Color scheme
        const costColor = '#ef4444';  // Red for costs
        const savingsColor = '#22c55e';  // Green for savings
        const decisionColors = [
            '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899',
            '#06b6d4', '#84cc16', '#f97316', '#6366f1', '#ef4444'
        ];

        // Discount rate (WACC) used to compute discounted NPV
        const WACC = 0.0735; // 7.35%

        // Helper to parse quarter strings into sortable numeric parts { year, q }
        // Supports formats: "Q1 2024", "Q1-2024", "Q1FY26", "FY26_Q1", "2026_Q1", "2026 Q1", etc.
        function parseQuarter(q) {
            if (!q) return { year: 0, q: 0 };
            const s = String(q).trim();

            // Q1FY26 or Q1FY2026 or Q1 FY26
            let m = s.match(/Q\s*(\d+)\s*FY\s*(\d{2,4})/i) || s.match(/Q(\d+)FY(\d{2,4})/i);
            if (m) {
                let qn = parseInt(m[1]);
                let yy = String(m[2]);
                if (yy.length === 2) yy = '20' + yy;
                return { year: parseInt(yy), q: qn };
            }

            // FY26_Q1 or 2026_Q1 or 2026 Q1
            m = s.match(/(?:FY\s*)?(\d{2,4})[ _\-]*Q\s*(\d+)/i);
            if (m) {
                let year = String(m[1]);
                if (year.length === 2) year = '20' + year;
                return { year: parseInt(year), q: parseInt(m[2]) };
            }

            // Q1 2024 or Q1_2024 or Q1-2024
            m = s.match(/Q\s*(\d+)\s*(\d{4})/i) || s.match(/Q(\d+)[ _\-]?(\d{4})/i);
            if (m) return { year: parseInt(m[2]), q: parseInt(m[1]) };

            // 2024 Q1
            m = s.match(/(\d{4})\s*Q\s*(\d+)/i);
            if (m) return { year: parseInt(m[1]), q: parseInt(m[2]) };

            // Fallback: try to extract a 4-digit year
            const m2 = s.match(/(\d{4})/);
            if (m2) return { year: parseInt(m2[1]), q: 0 };

            return { year: 0, q: 0 };
        }
        
        window.addEventListener('DOMContentLoaded', function() {
            // Try to load from decision-financials.csv file
            attemptAutoLoad();
        });
        
        function formatNumber(num) {
            return Math.abs(num).toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }
        
        function attemptAutoLoad() {
            
            
            // Try the expected filename first
            // Add a cache-busting timestamp so the browser always fetches the latest CSV
            const csvUrlPrimary = 'decision-financials.csv?t=' + Date.now();
            fetch(csvUrlPrimary)
                .then(response => {
                    
                    if (!response.ok) {
                        throw new Error(`CSV not found (status: ${response.status})`);
                    }
                    return response.text();
                })
                .then(csvText => {
                    // CSV loaded successfully
                    parseAndLoadData(csvText, false);
                })
                .catch(error => {
                    console.error('Primary CSV load failed:', error);
                    
                    // Try alternative filename without hyphen
                    
                    const csvUrlAlt = 'decisionfinancials.csv?t=' + Date.now();
                    return fetch(csvUrlAlt)
                        .then(response => {
                            if (!response.ok) throw new Error('Alternative also not found');
                            
                            return response.text();
                        })
                        .then(csvText => {
                            parseAndLoadData(csvText, false);
                        })
                        .catch(altError => {
                            console.error('Both filenames failed:', altError);
                            document.getElementById('decisionDropdown').innerHTML = 
                                '<span class="status-indicator empty"></span>Loading test data...';
                            
                            // Fallback to dummy data for testing
                            setTimeout(() => {
                                
                                loadDummyData();
                            }, 500);
                        });
                });
        }
        
        function parseAndLoadData(csvText, isTestData = false) {
            
            Papa.parse(csvText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                        
                        // Support both long and wide CSV formats. If the CSV is "wide"
                        // (one row per decision with Cost/Savings columns per quarter)
                        // convert it to the long format the dashboard expects.
                        let rows = results.data;

                        if (rows.length > 0) {
                            const keys = Object.keys(rows[0]);
                            const hasQuarter = keys.some(k => /quarter/i.test(k));
                            const hasCostOrSavings = keys.some(k => /cost|saving/i.test(k));

                            if (!hasQuarter && hasCostOrSavings) {
                                

                                // Identify quarter prefixes by stripping trailing Cost/Savings
                                const prefixes = new Set();
                                keys.forEach(k => {
                                    const m = k.match(/^(.*?)(?:[_\s-]?)(?:Cost|Savings)$/i);
                                    if (m && m[1]) prefixes.add(m[1]);
                                });

                                function normalizeQuarterPrefix(pref) {
                                    if (!pref) return pref;
                                    let s = String(pref).replace(/[_\-]+/g, ' ').trim();
                                    // Normalize a variety of common patterns to "Qn YYYY"
                                    // Examples handled: "Q1 2024", "Q1_2024", "2024_Q1", "Q1FY26", "Q1FY2026", "FY26_Q1"

                                    // Q1FY26 or Q1FY2026 or Q1 FY26
                                    let m = s.match(/Q\s*(\d+)\s*FY\s*(\d{2,4})/i) || s.match(/Q(\d+)FY(\d{2,4})/i);
                                    if (m) {
                                        let q = m[1];
                                        let yy = m[2];
                                        if (yy.length === 2) yy = '20' + yy;
                                        return `Q${q} ${yy}`;
                                    }

                                    // FY26_Q1 or 2026_Q1 or 2026 Q1
                                    m = s.match(/(?:FY\s*)?(\d{2,4})[ _\-]*Q\s*(\d+)/i);
                                    if (m) {
                                        let year = m[1];
                                        if (year.length === 2) year = '20' + year;
                                        const q = m[2];
                                        return `Q${q} ${year}`;
                                    }

                                    // Q1 2024 or Q1_2024
                                    m = s.match(/Q\s*(\d+)\s*(\d{4})/i) || s.match(/Q(\d+)[ _]?(\d{4})/i);
                                    if (m) return `Q${m[1]} ${m[2]}`;

                                    // 2024 Q1
                                    m = s.match(/(\d{4})\s*Q\s*(\d+)/i);
                                    if (m) return `Q${m[2]} ${m[1]}`;

                                    // Fallback to the original string trimmed
                                    return s;
                                }

                                const longRows = [];
                                rows.forEach(r => {
                                    const decisionId = r['DecisionID'] || r['decisionid'] || r['Decision Id'] || r['DecisionId'] || '';
                                    const decision = r['Decision'] || r['decision'] || '';
                                    const description = r['Description'] || r['description'] || '';

                                    prefixes.forEach(pref => {
                                        const prefLower = String(pref).toLowerCase();
                                        const costKey = keys.find(k => k.toLowerCase().startsWith(prefLower) && /cost/i.test(k));
                                        const savingsKey = keys.find(k => k.toLowerCase().startsWith(prefLower) && /saving/i.test(k));

                                        const cost = costKey ? parseFloat(r[costKey]) || 0 : 0;
                                        const savings = savingsKey ? parseFloat(r[savingsKey]) || 0 : 0;

                                        // If both are zero and both keys are absent, skip
                                        if (!costKey && !savingsKey) return;

                                        const quarter = normalizeQuarterPrefix(pref);

                                        longRows.push({
                                            DecisionID: decisionId,
                                            Decision: decision,
                                            Description: description,
                                            Quarter: quarter,
                                            Cost: cost,
                                            Savings: savings
                                        });
                                    });
                                });

                                rows = longRows;
                            }

                            // first row sample omitted for cleaner console output
                            processData(rows, isTestData);
                            updateDecisionDropdown();
                            updateDisplay();
                        } else {
                            console.error('No data found in CSV');
                            document.getElementById('decisionDropdown').innerHTML = 
                                '<span class="status-indicator empty"></span>No data in CSV';
                        }
                },
                error: function(error) {
                    console.error('Papa Parse error:', error);
                }
            });
        }
        
        function processData(rawData, isTestData = false) {
            const grouped = {};
            
            
            // Log column names to debug potential header issues
            if (rawData.length > 0) {
                
            }
            
            rawData.forEach((row, index) => {
                // Try multiple variations of column names to handle potential spaces
                const decision = row['Decision'] || row['decision'] || row[' Decision'] || row['Decision '];
                const decisionId = row['DecisionID'] || row['decisionid'] || row['DecisionId'] || row[' DecisionID'] || row['DecisionID '];
                
                if (!decision) {
                    
                    return;
                }
                
                    if (!grouped[decision]) {
                        // Preserve the raw DecisionID string (supports values like "AOM-01")
                        const idRaw = decisionId !== undefined && decisionId !== null ? String(decisionId).trim() : '';
                        grouped[decision] = {
                            // `id` is the display ID (string). We keep the original raw value so
                            // UI shows the human-friendly ID. Numeric sorting is handled separately.
                            id: idRaw,
                            name: decision.trim ? decision.trim() : decision,
                            description: (row['Description'] || row['description'] || row[' Description'] || '').trim ? (row['Description'] || row['description'] || '').trim() : '',
                            quarters: [],
                            costs: [],
                            savings: []
                        };
                }
                
                const quarter = row['Quarter'] || row['quarter'] || row[' Quarter'];
                const cost = parseFloat(row['Cost'] || row['cost'] || row[' Cost'] || 0);
                const savings = parseFloat(row['Savings'] || row['savings'] || row[' Savings'] || 0);
                
                grouped[decision].quarters.push(quarter);
                grouped[decision].costs.push(cost);
                grouped[decision].savings.push(savings);
            });
            
            decisionData = Object.values(grouped);
                // Sort: if both IDs are numeric, sort numerically. Otherwise sort by ID string.
                decisionData.sort((a, b) => {
                    const aNum = parseInt(a.id);
                    const bNum = parseInt(b.id);
                    const aIsNum = !isNaN(aNum);
                    const bIsNum = !isNaN(bNum);
                    if (aIsNum && bIsNum) return aNum - bNum;
                    if (aIsNum && !bIsNum) return -1;
                    if (!aIsNum && bIsNum) return 1;
                    return String(a.id).localeCompare(String(b.id));
                });
            
            
            if (decisionData.length > 0) {
                
            }

            // Compute discounted NPV per decision using WACC
            Object.values(grouped).forEach(d => {
                // Build an array of quarter entries and sort them chronologically
                const entries = (d.quarters || []).map((q, i) => ({
                    quarter: q,
                    cost: d.costs[i] || 0,
                    savings: d.savings[i] || 0
                }));

                entries.sort((a, b) => {
                    const A = parseQuarter(a.quarter);
                    const B = parseQuarter(b.quarter);
                    if (A.year !== B.year) return A.year - B.year;
                    if (A.q !== B.q) return A.q - B.q;
                    return String(a.quarter).localeCompare(String(b.quarter));
                });

                // Compute discounted NPV: sum_{t=0..} (savings_t - cost_t) / (1+WACC)^t
                let npv = 0;
                for (let t = 0; t < entries.length; t++) {
                    const cf = (entries[t].savings || 0) - (entries[t].cost || 0);
                    npv += cf / Math.pow(1 + WACC, t);
                }
                d.npv = npv;
            });
            
            const statusText = isTestData ? ' (Test Data)' : '';
            document.getElementById('decisionDropdown').innerHTML = 
                '<span class="status-indicator loaded"></span>' + decisionData.length + ' Decisions Loaded' + statusText;
        }
        
        function updateDecisionDropdown() {
            const menu = document.getElementById('decisionMenu');
            while (menu.children.length > 1) {
                menu.removeChild(menu.lastChild);
            }
            
            decisionData.forEach((decision, index) => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.title = decision.description;
                                // Build per-decision NPV display
                                const npvVal = typeof decision.npv === 'number' ? decision.npv : 0;
                                const npvSign = npvVal >= 0 ? '' : '-';
                                const npvColor = npvVal >= 0 ? '#10b981' : '#ef4444';
                                const npvText = `<span style="font-weight:700; margin-left:8px; color:${npvColor};">${npvSign}$${formatNumber(Math.round(Math.abs(npvVal)))}k</span>`;

                                item.innerHTML = `
                                        <input type="checkbox" id="decision-${index}" data-decision="${decision.name}">
                                        <label for="decision-${index}" style="flex: 1; cursor: pointer; display:flex; align-items:flex-start; gap:8px;">
                                                <div style="display:flex; align-items:baseline; gap:8px;">
                                                    <span style="font-weight: 600; color: #001C66;">${decision.id}.</span>
                                                    <div style="display:flex; flex-direction:column;">
                                                        <div style="font-weight:600; color:#001C66;">${decision.name} ${npvText}</div>
                                                        ${decision.description ? `<div style="font-size: 11px; color: #001C66; opacity: 0.7; margin-top: 2px;">${decision.description.substring(0, 50)}${decision.description.length > 50 ? '...' : ''}</div>` : ''}
                                                    </div>
                                                </div>
                                        </label>
                                `;
                menu.appendChild(item);
                
                item.querySelector('input').addEventListener('change', function() {
                    if (this.checked) {
                        selectedDecisions.add(decision.name);
                    } else {
                        selectedDecisions.delete(decision.name);
                    }
                    updateSelectAll();
                    updateDisplay();
                });
            });
        }
        
        document.getElementById('decisionDropdown').addEventListener('click', function() {
            document.getElementById('decisionMenu').classList.toggle('show');
        });
        
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.dropdown-container')) {
                document.getElementById('decisionMenu').classList.remove('show');
            }
        });
        
        document.getElementById('selectAll').addEventListener('change', function() {
            const checkboxes = document.querySelectorAll('#decisionMenu input[type="checkbox"]:not(#selectAll)');
            checkboxes.forEach(cb => {
                cb.checked = this.checked;
                const decisionName = cb.dataset.decision;
                if (this.checked) {
                    selectedDecisions.add(decisionName);
                } else {
                    selectedDecisions.delete(decisionName);
                }
            });
            updateDisplay();
        });
        
        function updateSelectAll() {
            const checkboxes = document.querySelectorAll('#decisionMenu input[type="checkbox"]:not(#selectAll)');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            const someChecked = Array.from(checkboxes).some(cb => cb.checked);
            
            const selectAll = document.getElementById('selectAll');
            selectAll.checked = allChecked;
            selectAll.indeterminate = !allChecked && someChecked;
        }
        
        document.querySelectorAll('.view-option').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.view-option').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentView = this.dataset.view;
                updateDisplay();
            });
        });
        
        function updateDisplay() {
            const selectedData = decisionData.filter(d => selectedDecisions.has(d.name));
            updateMetrics(selectedData);
            
            const activeGroup = document.getElementById('activeDecisionsGroup');
            const listContainer = document.getElementById('selectedDecisionsList');
            
            // Always show all decisions, but differentiate between selected and unselected
            const countElement = document.getElementById('decisionCount');
            if (countElement) {
                countElement.textContent = `${selectedData.length} selected`;
            }
            
            listContainer.innerHTML = decisionData.map(decision => {
                const isSelected = selectedDecisions.has(decision.name);
                // Truncate long names for compactness - increased from 16/13 to 28/25
                const displayName = decision.name.length > 28 ? 
                    decision.name.substring(0, 25) + '...' : 
                    decision.name;
                
                // Per-decision NPV badge
                const npvVal = typeof decision.npv === 'number' ? decision.npv : 0;
                const npvColor = npvVal >= 0 ? '#10b981' : '#ef4444';
                const npvBadge = `<span style="margin-left:8px; font-size:11px; font-weight:700; color:${npvColor};">$${formatNumber(Math.round(Math.abs(npvVal)))}k</span>`;

                return `
                    <div class="decision-chip ${isSelected ? '' : 'inactive'}" 
                         title="${decision.name}${decision.description ? ': ' + decision.description : ''}">
                        <span style="font-weight: 700; margin-right: 2px;">${decision.id}.</span>
                        ${displayName}
                        ${npvBadge}
                    </div>
                `;
            }).join('');
            
            updateWaterfallChart(selectedData);
            updateLegend();
        }
        
        function updateMetrics(data) {
            let totalNPV = 0;
            let totalCosts = 0;
            let totalSavings = 0;
            
            data.forEach(decision => {
                totalNPV += decision.npv || 0;
                totalCosts += decision.costs.reduce((a, b) => a + b, 0);
                totalSavings += decision.savings.reduce((a, b) => a + b, 0);
            });
            
            document.getElementById('totalNPV').textContent = '$' + formatNumber(totalNPV);
            document.getElementById('totalCosts').textContent = '$' + formatNumber(totalCosts);
            document.getElementById('totalSavings').textContent = '$' + formatNumber(totalSavings);
            document.getElementById('netBenefit').textContent = '$' + formatNumber(totalSavings - totalCosts);
        }
        
        function processWaterfallData(data) {
            const waterfallData = [];
            
            // Normalize quarter strings to a canonical form "Qn YYYY" and sort chronologically
            function normalizeQ(q) {
                if (!q) return '';
                const s = String(q).trim();

                // Q1FY26 or Q1FY2026 or Q1 FY26
                let m = s.match(/Q\s*(\d+)\s*FY\s*(\d{2,4})/i) || s.match(/Q(\d+)FY(\d{2,4})/i);
                if (m) {
                    let qn = +m[1];
                    let yy = String(m[2]);
                    if (yy.length === 2) yy = '20' + yy;
                    return `Q${qn} ${yy}`;
                }

                // FY26_Q1 or 2026_Q1 or 2026 Q1
                m = s.match(/(?:FY\s*)?(\d{2,4})[ _\-]*Q\s*(\d+)/i);
                if (m) {
                    let year = String(m[1]);
                    if (year.length === 2) year = '20' + year;
                    const qn = +m[2];
                    return `Q${qn} ${year}`;
                }

                // Q1 2024 or Q1_2024
                m = s.match(/Q\s*(\d+)\s*(\d{4})/i) || s.match(/Q(\d+)[ _]?(\d{4})/i);
                if (m) return `Q${+m[1]} ${m[2]}`;

                // 2024 Q1
                m = s.match(/(\d{4})\s*Q\s*(\d+)/i);
                if (m) return `Q${+m[2]} ${m[1]}`;

                // Fallback: return trimmed original
                return s;
            }

            // Build a normalized unique quarter list
            const allQuarters = [...new Set(data.flatMap(d => (d.quarters || []).map(normalizeQ)))].filter(Boolean);

            // Sort by year then quarter number
            allQuarters.sort((a, b) => {
                const pa = a.match(/Q(\d+)\s*(\d{4})/i);
                const pb = b.match(/Q(\d+)\s*(\d{4})/i);
                const ay = pa ? parseInt(pa[2]) : 0;
                const by = pb ? parseInt(pb[2]) : 0;
                const aq = pa ? parseInt(pa[1]) : 0;
                const bq = pb ? parseInt(pb[1]) : 0;
                if (ay !== by) return ay - by;
                if (aq !== bq) return aq - bq;
                return String(a).localeCompare(String(b));
            });
            
            // Prepare data for waterfall
            allQuarters.forEach(quarter => {
                data.forEach(decision => {
                    // Find index in decision.quarters matching the normalized quarter
                    const qIndex = (decision.quarters || []).findIndex(q => normalizeQ(q) === quarter);
                    if (qIndex !== -1) {
                        // Add cost entry
                        if (decision.costs[qIndex] > 0) {
                            waterfallData.push({
                                quarter: quarter,
                                decision: decision.name,
                                decisionId: decision.id,
                                type: 'cost',
                                value: -decision.costs[qIndex],
                                label: `${decision.name} Costs`
                            });
                        }
                        
                        // Add savings entry
                        if (decision.savings[qIndex] > 0) {
                            waterfallData.push({
                                quarter: quarter,
                                decision: decision.name,
                                decisionId: decision.id,
                                type: 'savings',
                                value: decision.savings[qIndex],
                                label: `${decision.name} Savings`
                            });
                        }
                    }
                });
            });
            
            if (currentView === 'aggregated') {
                // Aggregate by quarter and type
                const aggregated = d3.rollup(waterfallData,
                    v => d3.sum(v, d => d.value),
                    d => d.quarter,
                    d => d.type
                );

                // Build aggregatedData in the same sorted quarter order to ensure grouping
                const aggregatedData = [];
                allQuarters.forEach(quarter => {
                    const types = aggregated.get(quarter);
                    if (!types) return;
                    // Ensure consistent ordering: costs then savings
                    ['cost', 'savings'].forEach(type => {
                        const value = types.get(type) || 0;
                        if (value !== 0) {
                            aggregatedData.push({
                                quarter: quarter,
                                decision: 'All Decisions',
                                type: type,
                                value: value,
                                label: `${quarter} ${type === 'cost' ? 'Total Costs' : 'Total Savings'}`
                            });
                        }
                    });
                });

                return aggregatedData;
            }
            
            return waterfallData;
        }
        
        function updateWaterfallChart(data) {
            // Clear existing chart
            d3.select("#waterfallChart").selectAll("*").remove();
            
            if (data.length === 0) {
                const container = d3.select("#waterfallChart");
                container.append("div")
                    .style("text-align", "center")
                    .style("padding", "50px")
                    .style("color", "#001C66")
                    .text("Please select decisions to display the waterfall chart");
                return;
            }
            
            const waterfallData = processWaterfallData(data);
            
            // Calculate running totals
            let runningTotal = 0;
            const processedData = waterfallData.map((d, i) => {
                const start = runningTotal;
                const end = runningTotal + d.value;
                runningTotal = end;
                return {
                    ...d,
                    start: start,
                    end: end,
                    index: i
                };
            });
            
            drawWaterfall(processedData);
        }
        
        function drawWaterfall(data) {
            const container = d3.select("#waterfallChart");
            
            // Fixed margins for clean label display
            const margin = {top: 15, right: 70, bottom: 50, left: 70};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 360 - margin.top - margin.bottom;
            
            const svg = container.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Scales
            const x = d3.scaleBand()
                .domain(data.map((d, i) => i))
                .range([0, width])
                .padding(0.1);
            
            const yMin = d3.min(data, d => Math.min(d.start, d.end));
            const yMax = d3.max(data, d => Math.max(d.start, d.end));
            const yPadding = (yMax - yMin) * 0.1;
            
            const y = d3.scaleLinear()
                .domain([yMin - yPadding, yMax + yPadding])
                .range([height, 0]);
            
            // Identify quarter boundaries
            const quarterBoundaries = [];
            let lastQuarter = null;
            data.forEach((d, i) => {
                if (d.quarter !== lastQuarter) {
                    quarterBoundaries.push({quarter: d.quarter, start: i, end: i});
                    lastQuarter = d.quarter;
                } else {
                    quarterBoundaries[quarterBoundaries.length - 1].end = i;
                }
            });
            
            // Add quarter background shading
            quarterBoundaries.forEach((boundary, idx) => {
                if (idx % 2 === 0) {
                    g.append("rect")
                        .attr("x", x(boundary.start))
                        .attr("y", 0)
                        .attr("width", x(boundary.end) - x(boundary.start) + x.bandwidth())
                        .attr("height", height)
                        .attr("fill", "#f8fafc")
                        .attr("opacity", 0.5);
                }
            });
            
            // Add quarter divider lines
            quarterBoundaries.forEach((boundary, idx) => {
                if (idx > 0) {
                    g.append("line")
                        .attr("x1", x(boundary.start) - x.bandwidth() * 0.05)
                        .attr("x2", x(boundary.start) - x.bandwidth() * 0.05)
                        .attr("y1", 0)
                        .attr("y2", height)
                        .attr("stroke", "#cbd5e0")
                        .attr("stroke-width", 1)
                        .attr("stroke-dasharray", "3,3")
                        .attr("opacity", 0.5);
                }
            });
            
            // Add connector lines
            g.selectAll(".connector-line")
                .data(data.slice(0, -1))
                .enter().append("line")
                .attr("class", "connector-line")
                .attr("x1", (d, i) => x(i) + x.bandwidth())
                .attr("y1", d => y(d.end))
                .attr("x2", (d, i) => x(i + 1))
                .attr("y2", d => y(d.end));
            
            // Add bars
            const bars = g.selectAll(".bar")
                .data(data)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", (d, i) => x(i))
                .attr("y", d => y(Math.max(d.start, d.end)))
                .attr("width", x.bandwidth())
                .attr("height", d => Math.abs(y(d.start) - y(d.end)))
                .attr("fill", d => d.type === 'cost' ? costColor : savingsColor)
                .attr("opacity", 0.85);
            
            // Add hover effects
            bars.on("mouseover", function(event, d) {
                    d3.select(this)
                        .attr("opacity", 1)
                        .attr("stroke", "#001C66")
                        .attr("stroke-width", 2);
                    
                    const tooltip = document.getElementById("tooltip");
                    tooltip.innerHTML = `
                        <strong>${d.label}</strong><br>
                        ${currentView === 'detailed' ? `Decision: ${d.decision}<br>` : ''}
                        Quarter: ${d.quarter}<br>
                        ${d.type === 'cost' ? 'Cost' : 'Savings'}: $${formatNumber(Math.abs(d.value))}k<br>
                        Running Total: $${d.end.toFixed(1)}k
                    `;
                    tooltip.style.left = event.pageX + 10 + "px";
                    tooltip.style.top = event.pageY - 10 + "px";
                    tooltip.classList.add("visible");
                })
                .on("mouseout", function() {
                    d3.select(this)
                        .attr("opacity", 0.85)
                        .attr("stroke", "none");
                    document.getElementById("tooltip").classList.remove("visible");
                });
            
            // X-axis - clean mode with only quarter labels
            const xAxis = g.append("g")
                .attr("transform", `translate(0,${height})`);
            
            quarterBoundaries.forEach(boundary => {
                const centerX = (x(boundary.start) + x(boundary.end) + x.bandwidth()) / 2;
                xAxis.append("text")
                    .attr("x", centerX)
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .style("font-size", "14px")
                    .style("font-weight", "600")
                    .style("fill", "#001C66")
                    .text(boundary.quarter);
                
                xAxis.append("line")
                    .attr("x1", centerX)
                    .attr("x2", centerX)
                    .attr("y1", 0)
                    .attr("y2", 6)
                    .attr("stroke", "#001C66")
                    .attr("stroke-width", 1);
            });
            
            xAxis.append("line")
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", 0)
                .attr("y2", 0)
                .attr("stroke", "#001C66")
                .attr("stroke-width", 1);
            
            // Y-axis
            const yAxis = d3.axisLeft(y)
                .tickFormat(d => `$${formatNumber(d)}k`);
            
            g.append("g")
                .call(yAxis)
                .selectAll("text")
                .style("fill", "#001C66");
            
            g.selectAll(".domain, .tick line")
                .style("stroke", "#001C66");
            
            // Add axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .style("fill", "#001C66")
                .text("Cashflow ($k)");
            
            // Add zero line
            g.append("line")
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", y(0))
                .attr("y2", y(0))
                .attr("stroke", "#001C66")
                .attr("stroke-width", 1.5)
                .attr("opacity", 0.7);
            
            // Add final total label
            if (data.length > 0) {
                const lastBar = data[data.length - 1];
                g.append("text")
                    .attr("x", x(data.length - 1) + x.bandwidth() / 2)
                    .attr("y", y(lastBar.end) - 10)
                    .attr("text-anchor", "middle")
                    .attr("font-weight", "bold")
                    .attr("font-size", "14px")
                    .attr("fill", lastBar.end >= 0 ? savingsColor : costColor)
                    .text(`Net: $${formatNumber(lastBar.end)}k`);
            }
        }
        
        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';
            
            const items = [
                { color: costColor, label: 'Costs (Negative Cashflow)' },
                { color: savingsColor, label: 'Savings (Positive Cashflow)' }
            ];
            
            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'legend-item';
                div.innerHTML = `
                    <div class="legend-color" style="background: ${item.color}"></div>
                    <span>${item.label}</span>
                `;
                legend.appendChild(div);
            });
        }
        
        function loadDummyData() {
            // Generate dummy data for testing
            const dummyCSV = generateDummyCSV();
            parseAndLoadData(dummyCSV, true);  // Pass true to indicate test data
            
            // Auto-select first 3 decisions for demo
            setTimeout(() => {
                const firstThree = decisionData.slice(0, 3);
                firstThree.forEach((decision, index) => {
                    selectedDecisions.add(decision.name);
                    const checkbox = document.getElementById(`decision-${index}`);
                    if (checkbox) checkbox.checked = true;
                });
                updateSelectAll();
                updateDisplay();
            }, 100);
        }
        
        function generateDummyCSV() {
            const decisions = [
                { id: 1, name: "Cloud Migration", description: "Migrate infrastructure to cloud services for scalability" },
                { id: 2, name: "Process Automation", description: "Automate manual processes using RPA technology" },
                { id: 3, name: "Data Analytics Platform", description: "Implement advanced analytics for better insights" },
                { id: 4, name: "Security Enhancement", description: "Upgrade cybersecurity infrastructure and protocols" },
                { id: 5, name: "Customer Portal", description: "Develop self-service customer portal to reduce support costs" },
                { id: 6, name: "Supply Chain Optimization", description: "Optimize supply chain with AI-driven forecasting" },
                { id: 7, name: "Remote Work Infrastructure", description: "Enhance remote work capabilities and tools" },
                { id: 8, name: "Green Energy Initiative", description: "Transition to renewable energy sources" },
                { id: 9, name: "Training Program", description: "Comprehensive employee skill development program" },
                { id: 10, name: "ERP System Upgrade", description: "Modernize enterprise resource planning system" }
            ];
            
            const quarters = ["Q1 2024", "Q2 2024", "Q3 2024", "Q4 2024"];
            
            let csvRows = ["DecisionID,Decision,Description,Quarter,Cost,Savings,NPV"];
            
            decisions.forEach(decision => {
                let allCosts = [];
                let allSavings = [];
                
                // First, generate all quarters data
                quarters.forEach((quarter, qIndex) => {
                    let cost, savings;
                    
                    if (qIndex === 0) {
                        // Higher initial costs
                        cost = Math.floor(Math.random() * 150 + 100); // 100-250k
                        savings = Math.floor(Math.random() * 50 + 20); // 20-70k
                    } else if (qIndex === 1) {
                        // Moderate costs, increasing savings
                        cost = Math.floor(Math.random() * 100 + 50); // 50-150k
                        savings = Math.floor(Math.random() * 100 + 50); // 50-150k
                    } else {
                        // Lower costs, higher savings
                        cost = Math.floor(Math.random() * 50 + 20); // 20-70k
                        savings = Math.floor(Math.random() * 150 + 100); // 100-250k
                    }
                    
                    allCosts.push(cost);
                    allSavings.push(savings);
                });
                
                // Calculate NPV (simplified - just total savings minus total costs)
                const totalCosts = allCosts.reduce((a, b) => a + b, 0);
                const totalSavings = allSavings.reduce((a, b) => a + b, 0);
                const npv = totalSavings - totalCosts;
                
                // Now create the CSV rows with the same NPV for all quarters of a decision
                quarters.forEach((quarter, qIndex) => {
                    csvRows.push(`${decision.id},${decision.name},"${decision.description}",${quarter},${allCosts[qIndex]},${allSavings[qIndex]},${npv}`);
                });
            });
            
            return csvRows.join('\n');
        }
    </script>
</body>
</html>